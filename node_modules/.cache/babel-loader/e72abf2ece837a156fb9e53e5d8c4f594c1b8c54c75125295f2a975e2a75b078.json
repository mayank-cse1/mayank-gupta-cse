{"ast":null,"code":"import _toArray from \"C:/Users/mayan/source/repos/mayankcse.github.io/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"C:/Users/mayan/source/repos/mayankcse.github.io/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\r\n * @typedef {import('vfile').VFileValue} VFileValue\r\n * @typedef {import('..').Processor} Processor\r\n * @typedef {import('..').Plugin} Plugin\r\n * @typedef {import('..').Preset} Preset\r\n * @typedef {import('..').Pluggable} Pluggable\r\n * @typedef {import('..').PluggableList} PluggableList\r\n * @typedef {import('..').Transformer} Transformer\r\n * @typedef {import('..').Parser} Parser\r\n * @typedef {import('..').Compiler} Compiler\r\n * @typedef {import('..').RunCallback} RunCallback\r\n * @typedef {import('..').ProcessCallback} ProcessCallback\r\n *\r\n * @typedef Context\r\n * @property {Node} tree\r\n * @property {VFile} file\r\n */\n\nimport { bail } from 'bail';\nimport isBuffer from 'is-buffer';\nimport extend from 'extend';\nimport isPlainObj from 'is-plain-obj';\nimport { trough } from 'trough';\nimport { VFile } from 'vfile';\n\n// Expose a frozen processor.\nexport var unified = base().freeze();\nvar own = {}.hasOwnProperty;\n\n// Function to create the first processor.\n/**\r\n * @returns {Processor}\r\n */\nfunction base() {\n  var transformers = trough();\n  /** @type {Processor['attachers']} */\n  var attachers = [];\n  /** @type {Record<string, unknown>} */\n  var namespace = {};\n  /** @type {boolean|undefined} */\n  var frozen;\n  var freezeIndex = -1;\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data;\n  processor.Parser = undefined;\n  processor.Compiler = undefined;\n\n  // Lock.\n  processor.freeze = freeze;\n\n  // Plugins.\n  processor.attachers = attachers;\n  // @ts-expect-error: overloads are handled.\n  processor.use = use;\n\n  // API.\n  processor.parse = parse;\n  processor.stringify = stringify;\n  // @ts-expect-error: overloads are handled.\n  processor.run = run;\n  processor.runSync = runSync;\n  // @ts-expect-error: overloads are handled.\n  processor.process = process;\n  processor.processSync = processSync;\n\n  // Expose.\n  return processor;\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    var destination = base();\n    var index = -1;\n    while (++index < attachers.length) {\n      destination.use.apply(destination, _toConsumableArray(attachers[index]));\n    }\n    destination.data(extend(true, {}, namespace));\n    return destination;\n  }\n\n  /**\r\n   * @param {string|Record<string, unknown>} [key]\r\n   * @param {unknown} [value]\r\n   * @returns {unknown}\r\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      }\n\n      // Get `key`.\n      return own.call(namespace, key) && namespace[key] || null;\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    }\n\n    // Get space.\n    return namespace;\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor;\n    }\n    while (++freezeIndex < attachers.length) {\n      var _attachers$freezeInde = _toArray(attachers[freezeIndex]),\n        attacher = _attachers$freezeInde[0],\n        options = _attachers$freezeInde.slice(1);\n      if (options[0] === false) {\n        continue;\n      }\n      if (options[0] === true) {\n        options[0] = undefined;\n      }\n\n      /** @type {Transformer|void} */\n      var transformer = attacher.call.apply(attacher, [processor].concat(_toConsumableArray(options)));\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n    frozen = true;\n    freezeIndex = Number.POSITIVE_INFINITY;\n    return processor;\n  }\n\n  /**\r\n   * @param {Pluggable|null|undefined} [value]\r\n   * @param {...unknown} options\r\n   * @returns {Processor}\r\n   */\n  function use(value) {\n    for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      options[_key - 1] = arguments[_key];\n    }\n    /** @type {Record<string, unknown>|undefined} */\n    var settings;\n    assertUnfrozen('use', frozen);\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(void 0, [value].concat(options));\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`');\n    }\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings);\n    }\n    return processor;\n\n    /**\r\n     * @param {import('..').Pluggable<unknown[]>} value\r\n     * @returns {void}\r\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          var _value = _toArray(value),\n            plugin = _value[0],\n            _options = _value.slice(1);\n          addPlugin.apply(void 0, [plugin].concat(_toConsumableArray(_options)));\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`');\n      }\n    }\n\n    /**\r\n     * @param {Preset} result\r\n     * @returns {void}\r\n     */\n    function addPreset(result) {\n      addList(result.plugins);\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings);\n      }\n    }\n\n    /**\r\n     * @param {PluggableList|null|undefined} [plugins]\r\n     * @returns {void}\r\n     */\n    function addList(plugins) {\n      var index = -1;\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          var thing = plugins[index];\n          add(thing);\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n\n    /**\r\n     * @param {Plugin} plugin\r\n     * @param {...unknown} [value]\r\n     * @returns {void}\r\n     */\n    function addPlugin(plugin, value) {\n      var index = -1;\n      /** @type {Processor['attachers'][number]|undefined} */\n      var entry;\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index];\n          break;\n        }\n      }\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value);\n        }\n        entry[1] = value;\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push(Array.prototype.slice.call(arguments));\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze();\n    var file = vfile(doc);\n    var Parser = processor.Parser;\n    assertParser('parse', Parser);\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse();\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze();\n    var file = vfile(doc);\n    var Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile();\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n\n  /**\r\n   * @param {Node} node\r\n   * @param {VFileCompatible|RunCallback} [doc]\r\n   * @param {RunCallback} [callback]\r\n   * @returns {Promise<Node>|void}\r\n   */\n  function run(node, doc, callback) {\n    assertNode(node);\n    processor.freeze();\n    if (!callback && typeof doc === 'function') {\n      callback = doc;\n      doc = undefined;\n    }\n    if (!callback) {\n      return new Promise(executor);\n    }\n    executor(null, callback);\n\n    /**\r\n     * @param {null|((node: Node) => void)} resolve\r\n     * @param {(error: Error) => void} reject\r\n     * @returns {void}\r\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done);\n\n      /**\r\n       * @param {Error|null} error\r\n       * @param {Node} tree\r\n       * @param {VFile} file\r\n       * @returns {void}\r\n       */\n      function done(error, tree, file) {\n        tree = tree || node;\n        if (error) {\n          reject(error);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file);\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    var result;\n    /** @type {boolean|undefined} */\n    var complete;\n    processor.run(node, file, done);\n    assertDone('runSync', 'run', complete);\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result;\n\n    /**\r\n     * @param {Error|null} [error]\r\n     * @param {Node} [tree]\r\n     * @returns {void}\r\n     */\n    function done(error, tree) {\n      bail(error);\n      result = tree;\n      complete = true;\n    }\n  }\n\n  /**\r\n   * @param {VFileCompatible} doc\r\n   * @param {ProcessCallback} [callback]\r\n   * @returns {Promise<VFile>|undefined}\r\n   */\n  function process(doc, callback) {\n    processor.freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n    if (!callback) {\n      return new Promise(executor);\n    }\n    executor(null, callback);\n\n    /**\r\n     * @param {null|((file: VFile) => void)} resolve\r\n     * @param {(error?: Error|null|undefined) => void} reject\r\n     * @returns {void}\r\n     */\n    function executor(resolve, reject) {\n      var file = vfile(doc);\n      processor.run(processor.parse(file), file, function (error, tree, file) {\n        if (error || !tree || !file) {\n          done(error);\n        } else {\n          /** @type {unknown} */\n          var result = processor.stringify(tree, file);\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result;\n          } else {\n            file.result = result;\n          }\n          done(error, file);\n        }\n      });\n\n      /**\r\n       * @param {Error|null|undefined} [error]\r\n       * @param {VFile|undefined} [file]\r\n       * @returns {void}\r\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file);\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    var complete;\n    processor.freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    var file = vfile(doc);\n    processor.process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n\n    /**\r\n     * @param {Error|null|undefined} [error]\r\n     * @returns {void}\r\n     */\n    function done(error) {\n      complete = true;\n      bail(error);\n    }\n  }\n}\n\n/**\r\n * Check if `value` is a constructor.\r\n *\r\n * @param {unknown} value\r\n * @param {string} name\r\n * @returns {boolean}\r\n */\nfunction newable(value, name) {\n  return typeof value === 'function' &&\n  // Prototypes do exist.\n  // type-coverage:ignore-next-line\n  value.prototype && (\n  // A function with keys in its prototype is probably a constructor.\n  // Classes’ prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  // type-coverage:ignore-next-line\n  keys(value.prototype) || name in value.prototype);\n}\n\n/**\r\n * Check if `value` is an object with keys.\r\n *\r\n * @param {Record<string, unknown>} value\r\n * @returns {boolean}\r\n */\nfunction keys(value) {\n  /** @type {string} */\n  var key;\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\r\n * Assert a parser is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Parser}\r\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`');\n  }\n}\n\n/**\r\n * Assert a compiler is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Compiler}\r\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`');\n  }\n}\n\n/**\r\n * Assert the processor is not frozen.\r\n *\r\n * @param {string} name\r\n * @param {unknown} frozen\r\n * @returns {asserts frozen is false}\r\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\n  }\n}\n\n/**\r\n * Assert `node` is a unist node.\r\n *\r\n * @param {unknown} node\r\n * @returns {asserts node is Node}\r\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`');\n    // Fine.\n  }\n}\n\n/**\r\n * Assert that `complete` is `true`.\r\n *\r\n * @param {string} name\r\n * @param {string} asyncName\r\n * @param {unknown} complete\r\n * @returns {asserts complete is true}\r\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}\n\n/**\r\n * @param {VFileCompatible} [value]\r\n * @returns {VFile}\r\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value);\n}\n\n/**\r\n * @param {VFileCompatible} [value]\r\n * @returns {value is VFile}\r\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\n}\n\n/**\r\n * @param {unknown} [value]\r\n * @returns {value is VFileValue}\r\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value);\n}","map":{"version":3,"names":["bail","isBuffer","extend","isPlainObj","trough","VFile","unified","base","freeze","own","hasOwnProperty","transformers","attachers","namespace","frozen","freezeIndex","processor","data","Parser","undefined","Compiler","use","parse","stringify","run","runSync","process","processSync","destination","index","length","apply","_toConsumableArray","key","value","arguments","assertUnfrozen","call","_attachers$freezeInde","_toArray","attacher","options","slice","transformer","concat","Number","POSITIVE_INFINITY","_len","Array","_key","settings","addPlugin","isArray","addList","addPreset","TypeError","Object","assign","add","_value","plugin","result","plugins","thing","entry","push","prototype","doc","file","vfile","assertParser","newable","String","node","assertCompiler","assertNode","compile","callback","Promise","executor","resolve","reject","done","error","tree","complete","assertDone","looksLikeAVFileValue","name","keys","Error","type","asyncName","looksLikeAVFile","Boolean"],"sources":["C:/Users/mayan/source/repos/mayankcse.github.io/node_modules/unified/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\r\n * @typedef {import('vfile').VFileValue} VFileValue\r\n * @typedef {import('..').Processor} Processor\r\n * @typedef {import('..').Plugin} Plugin\r\n * @typedef {import('..').Preset} Preset\r\n * @typedef {import('..').Pluggable} Pluggable\r\n * @typedef {import('..').PluggableList} PluggableList\r\n * @typedef {import('..').Transformer} Transformer\r\n * @typedef {import('..').Parser} Parser\r\n * @typedef {import('..').Compiler} Compiler\r\n * @typedef {import('..').RunCallback} RunCallback\r\n * @typedef {import('..').ProcessCallback} ProcessCallback\r\n *\r\n * @typedef Context\r\n * @property {Node} tree\r\n * @property {VFile} file\r\n */\r\n\r\nimport {bail} from 'bail'\r\nimport isBuffer from 'is-buffer'\r\nimport extend from 'extend'\r\nimport isPlainObj from 'is-plain-obj'\r\nimport {trough} from 'trough'\r\nimport {VFile} from 'vfile'\r\n\r\n// Expose a frozen processor.\r\nexport const unified = base().freeze()\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n// Function to create the first processor.\r\n/**\r\n * @returns {Processor}\r\n */\r\nfunction base() {\r\n  const transformers = trough()\r\n  /** @type {Processor['attachers']} */\r\n  const attachers = []\r\n  /** @type {Record<string, unknown>} */\r\n  let namespace = {}\r\n  /** @type {boolean|undefined} */\r\n  let frozen\r\n  let freezeIndex = -1\r\n\r\n  // Data management.\r\n  // @ts-expect-error: overloads are handled.\r\n  processor.data = data\r\n  processor.Parser = undefined\r\n  processor.Compiler = undefined\r\n\r\n  // Lock.\r\n  processor.freeze = freeze\r\n\r\n  // Plugins.\r\n  processor.attachers = attachers\r\n  // @ts-expect-error: overloads are handled.\r\n  processor.use = use\r\n\r\n  // API.\r\n  processor.parse = parse\r\n  processor.stringify = stringify\r\n  // @ts-expect-error: overloads are handled.\r\n  processor.run = run\r\n  processor.runSync = runSync\r\n  // @ts-expect-error: overloads are handled.\r\n  processor.process = process\r\n  processor.processSync = processSync\r\n\r\n  // Expose.\r\n  return processor\r\n\r\n  // Create a new processor based on the processor in the current scope.\r\n  /** @type {Processor} */\r\n  function processor() {\r\n    const destination = base()\r\n    let index = -1\r\n\r\n    while (++index < attachers.length) {\r\n      destination.use(...attachers[index])\r\n    }\r\n\r\n    destination.data(extend(true, {}, namespace))\r\n\r\n    return destination\r\n  }\r\n\r\n  /**\r\n   * @param {string|Record<string, unknown>} [key]\r\n   * @param {unknown} [value]\r\n   * @returns {unknown}\r\n   */\r\n  function data(key, value) {\r\n    if (typeof key === 'string') {\r\n      // Set `key`.\r\n      if (arguments.length === 2) {\r\n        assertUnfrozen('data', frozen)\r\n        namespace[key] = value\r\n        return processor\r\n      }\r\n\r\n      // Get `key`.\r\n      return (own.call(namespace, key) && namespace[key]) || null\r\n    }\r\n\r\n    // Set space.\r\n    if (key) {\r\n      assertUnfrozen('data', frozen)\r\n      namespace = key\r\n      return processor\r\n    }\r\n\r\n    // Get space.\r\n    return namespace\r\n  }\r\n\r\n  /** @type {Processor['freeze']} */\r\n  function freeze() {\r\n    if (frozen) {\r\n      return processor\r\n    }\r\n\r\n    while (++freezeIndex < attachers.length) {\r\n      const [attacher, ...options] = attachers[freezeIndex]\r\n\r\n      if (options[0] === false) {\r\n        continue\r\n      }\r\n\r\n      if (options[0] === true) {\r\n        options[0] = undefined\r\n      }\r\n\r\n      /** @type {Transformer|void} */\r\n      const transformer = attacher.call(processor, ...options)\r\n\r\n      if (typeof transformer === 'function') {\r\n        transformers.use(transformer)\r\n      }\r\n    }\r\n\r\n    frozen = true\r\n    freezeIndex = Number.POSITIVE_INFINITY\r\n\r\n    return processor\r\n  }\r\n\r\n  /**\r\n   * @param {Pluggable|null|undefined} [value]\r\n   * @param {...unknown} options\r\n   * @returns {Processor}\r\n   */\r\n  function use(value, ...options) {\r\n    /** @type {Record<string, unknown>|undefined} */\r\n    let settings\r\n\r\n    assertUnfrozen('use', frozen)\r\n\r\n    if (value === null || value === undefined) {\r\n      // Empty.\r\n    } else if (typeof value === 'function') {\r\n      addPlugin(value, ...options)\r\n    } else if (typeof value === 'object') {\r\n      if (Array.isArray(value)) {\r\n        addList(value)\r\n      } else {\r\n        addPreset(value)\r\n      }\r\n    } else {\r\n      throw new TypeError('Expected usable value, not `' + value + '`')\r\n    }\r\n\r\n    if (settings) {\r\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\r\n    }\r\n\r\n    return processor\r\n\r\n    /**\r\n     * @param {import('..').Pluggable<unknown[]>} value\r\n     * @returns {void}\r\n     */\r\n    function add(value) {\r\n      if (typeof value === 'function') {\r\n        addPlugin(value)\r\n      } else if (typeof value === 'object') {\r\n        if (Array.isArray(value)) {\r\n          const [plugin, ...options] = value\r\n          addPlugin(plugin, ...options)\r\n        } else {\r\n          addPreset(value)\r\n        }\r\n      } else {\r\n        throw new TypeError('Expected usable value, not `' + value + '`')\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {Preset} result\r\n     * @returns {void}\r\n     */\r\n    function addPreset(result) {\r\n      addList(result.plugins)\r\n\r\n      if (result.settings) {\r\n        settings = Object.assign(settings || {}, result.settings)\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {PluggableList|null|undefined} [plugins]\r\n     * @returns {void}\r\n     */\r\n    function addList(plugins) {\r\n      let index = -1\r\n\r\n      if (plugins === null || plugins === undefined) {\r\n        // Empty.\r\n      } else if (Array.isArray(plugins)) {\r\n        while (++index < plugins.length) {\r\n          const thing = plugins[index]\r\n          add(thing)\r\n        }\r\n      } else {\r\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @param {Plugin} plugin\r\n     * @param {...unknown} [value]\r\n     * @returns {void}\r\n     */\r\n    function addPlugin(plugin, value) {\r\n      let index = -1\r\n      /** @type {Processor['attachers'][number]|undefined} */\r\n      let entry\r\n\r\n      while (++index < attachers.length) {\r\n        if (attachers[index][0] === plugin) {\r\n          entry = attachers[index]\r\n          break\r\n        }\r\n      }\r\n\r\n      if (entry) {\r\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\r\n          value = extend(true, entry[1], value)\r\n        }\r\n\r\n        entry[1] = value\r\n      } else {\r\n        // @ts-expect-error: fine.\r\n        attachers.push([...arguments])\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @type {Processor['parse']} */\r\n  function parse(doc) {\r\n    processor.freeze()\r\n    const file = vfile(doc)\r\n    const Parser = processor.Parser\r\n    assertParser('parse', Parser)\r\n\r\n    if (newable(Parser, 'parse')) {\r\n      // @ts-expect-error: `newable` checks this.\r\n      return new Parser(String(file), file).parse()\r\n    }\r\n\r\n    // @ts-expect-error: `newable` checks this.\r\n    return Parser(String(file), file) // eslint-disable-line new-cap\r\n  }\r\n\r\n  /** @type {Processor['stringify']} */\r\n  function stringify(node, doc) {\r\n    processor.freeze()\r\n    const file = vfile(doc)\r\n    const Compiler = processor.Compiler\r\n    assertCompiler('stringify', Compiler)\r\n    assertNode(node)\r\n\r\n    if (newable(Compiler, 'compile')) {\r\n      // @ts-expect-error: `newable` checks this.\r\n      return new Compiler(node, file).compile()\r\n    }\r\n\r\n    // @ts-expect-error: `newable` checks this.\r\n    return Compiler(node, file) // eslint-disable-line new-cap\r\n  }\r\n\r\n  /**\r\n   * @param {Node} node\r\n   * @param {VFileCompatible|RunCallback} [doc]\r\n   * @param {RunCallback} [callback]\r\n   * @returns {Promise<Node>|void}\r\n   */\r\n  function run(node, doc, callback) {\r\n    assertNode(node)\r\n    processor.freeze()\r\n\r\n    if (!callback && typeof doc === 'function') {\r\n      callback = doc\r\n      doc = undefined\r\n    }\r\n\r\n    if (!callback) {\r\n      return new Promise(executor)\r\n    }\r\n\r\n    executor(null, callback)\r\n\r\n    /**\r\n     * @param {null|((node: Node) => void)} resolve\r\n     * @param {(error: Error) => void} reject\r\n     * @returns {void}\r\n     */\r\n    function executor(resolve, reject) {\r\n      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\r\n      transformers.run(node, vfile(doc), done)\r\n\r\n      /**\r\n       * @param {Error|null} error\r\n       * @param {Node} tree\r\n       * @param {VFile} file\r\n       * @returns {void}\r\n       */\r\n      function done(error, tree, file) {\r\n        tree = tree || node\r\n        if (error) {\r\n          reject(error)\r\n        } else if (resolve) {\r\n          resolve(tree)\r\n        } else {\r\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\r\n          callback(null, tree, file)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @type {Processor['runSync']} */\r\n  function runSync(node, file) {\r\n    /** @type {Node|undefined} */\r\n    let result\r\n    /** @type {boolean|undefined} */\r\n    let complete\r\n\r\n    processor.run(node, file, done)\r\n\r\n    assertDone('runSync', 'run', complete)\r\n\r\n    // @ts-expect-error: we either bailed on an error or have a tree.\r\n    return result\r\n\r\n    /**\r\n     * @param {Error|null} [error]\r\n     * @param {Node} [tree]\r\n     * @returns {void}\r\n     */\r\n    function done(error, tree) {\r\n      bail(error)\r\n      result = tree\r\n      complete = true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {VFileCompatible} doc\r\n   * @param {ProcessCallback} [callback]\r\n   * @returns {Promise<VFile>|undefined}\r\n   */\r\n  function process(doc, callback) {\r\n    processor.freeze()\r\n    assertParser('process', processor.Parser)\r\n    assertCompiler('process', processor.Compiler)\r\n\r\n    if (!callback) {\r\n      return new Promise(executor)\r\n    }\r\n\r\n    executor(null, callback)\r\n\r\n    /**\r\n     * @param {null|((file: VFile) => void)} resolve\r\n     * @param {(error?: Error|null|undefined) => void} reject\r\n     * @returns {void}\r\n     */\r\n    function executor(resolve, reject) {\r\n      const file = vfile(doc)\r\n\r\n      processor.run(processor.parse(file), file, (error, tree, file) => {\r\n        if (error || !tree || !file) {\r\n          done(error)\r\n        } else {\r\n          /** @type {unknown} */\r\n          const result = processor.stringify(tree, file)\r\n\r\n          if (result === undefined || result === null) {\r\n            // Empty.\r\n          } else if (looksLikeAVFileValue(result)) {\r\n            file.value = result\r\n          } else {\r\n            file.result = result\r\n          }\r\n\r\n          done(error, file)\r\n        }\r\n      })\r\n\r\n      /**\r\n       * @param {Error|null|undefined} [error]\r\n       * @param {VFile|undefined} [file]\r\n       * @returns {void}\r\n       */\r\n      function done(error, file) {\r\n        if (error || !file) {\r\n          reject(error)\r\n        } else if (resolve) {\r\n          resolve(file)\r\n        } else {\r\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\r\n          callback(null, file)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @type {Processor['processSync']} */\r\n  function processSync(doc) {\r\n    /** @type {boolean|undefined} */\r\n    let complete\r\n\r\n    processor.freeze()\r\n    assertParser('processSync', processor.Parser)\r\n    assertCompiler('processSync', processor.Compiler)\r\n\r\n    const file = vfile(doc)\r\n\r\n    processor.process(file, done)\r\n\r\n    assertDone('processSync', 'process', complete)\r\n\r\n    return file\r\n\r\n    /**\r\n     * @param {Error|null|undefined} [error]\r\n     * @returns {void}\r\n     */\r\n    function done(error) {\r\n      complete = true\r\n      bail(error)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check if `value` is a constructor.\r\n *\r\n * @param {unknown} value\r\n * @param {string} name\r\n * @returns {boolean}\r\n */\r\nfunction newable(value, name) {\r\n  return (\r\n    typeof value === 'function' &&\r\n    // Prototypes do exist.\r\n    // type-coverage:ignore-next-line\r\n    value.prototype &&\r\n    // A function with keys in its prototype is probably a constructor.\r\n    // Classes’ prototype methods are not enumerable, so we check if some value\r\n    // exists in the prototype.\r\n    // type-coverage:ignore-next-line\r\n    (keys(value.prototype) || name in value.prototype)\r\n  )\r\n}\r\n\r\n/**\r\n * Check if `value` is an object with keys.\r\n *\r\n * @param {Record<string, unknown>} value\r\n * @returns {boolean}\r\n */\r\nfunction keys(value) {\r\n  /** @type {string} */\r\n  let key\r\n\r\n  for (key in value) {\r\n    if (own.call(value, key)) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Assert a parser is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Parser}\r\n */\r\nfunction assertParser(name, value) {\r\n  if (typeof value !== 'function') {\r\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\r\n  }\r\n}\r\n\r\n/**\r\n * Assert a compiler is available.\r\n *\r\n * @param {string} name\r\n * @param {unknown} value\r\n * @returns {asserts value is Compiler}\r\n */\r\nfunction assertCompiler(name, value) {\r\n  if (typeof value !== 'function') {\r\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\r\n  }\r\n}\r\n\r\n/**\r\n * Assert the processor is not frozen.\r\n *\r\n * @param {string} name\r\n * @param {unknown} frozen\r\n * @returns {asserts frozen is false}\r\n */\r\nfunction assertUnfrozen(name, frozen) {\r\n  if (frozen) {\r\n    throw new Error(\r\n      'Cannot call `' +\r\n        name +\r\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Assert `node` is a unist node.\r\n *\r\n * @param {unknown} node\r\n * @returns {asserts node is Node}\r\n */\r\nfunction assertNode(node) {\r\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\r\n  // type-coverage:ignore-next-line\r\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\r\n    throw new TypeError('Expected node, got `' + node + '`')\r\n    // Fine.\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that `complete` is `true`.\r\n *\r\n * @param {string} name\r\n * @param {string} asyncName\r\n * @param {unknown} complete\r\n * @returns {asserts complete is true}\r\n */\r\nfunction assertDone(name, asyncName, complete) {\r\n  if (!complete) {\r\n    throw new Error(\r\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * @param {VFileCompatible} [value]\r\n * @returns {VFile}\r\n */\r\nfunction vfile(value) {\r\n  return looksLikeAVFile(value) ? value : new VFile(value)\r\n}\r\n\r\n/**\r\n * @param {VFileCompatible} [value]\r\n * @returns {value is VFile}\r\n */\r\nfunction looksLikeAVFile(value) {\r\n  return Boolean(\r\n    value &&\r\n      typeof value === 'object' &&\r\n      'message' in value &&\r\n      'messages' in value\r\n  )\r\n}\r\n\r\n/**\r\n * @param {unknown} [value]\r\n * @returns {value is VFileValue}\r\n */\r\nfunction looksLikeAVFileValue(value) {\r\n  return typeof value === 'string' || isBuffer(value)\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}