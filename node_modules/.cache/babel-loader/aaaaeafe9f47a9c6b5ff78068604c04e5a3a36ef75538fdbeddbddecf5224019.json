{"ast":null,"code":"/**\r\n * @typedef {import('unist').Node} Node\r\n */\n\n/**\r\n * @typedef {Array<Node> | string} ChildrenOrValue\r\n *   List to use as `children` or value to use as `value`.\r\n *\r\n * @typedef {Record<string, unknown>} Props\r\n *   Other fields to add to the node.\r\n */\n\n/**\r\n * Build a node.\r\n *\r\n * @param type\r\n *   Node type.\r\n * @param props\r\n *   Fields assigned to node.\r\n * @param value\r\n *   Children of node or value of `node` (cast to string).\r\n * @returns\r\n *   Built node.\r\n */\nexport var u =\n/**\r\n * @type {(\r\n *   (<T extends string>(type: T) => {type: T}) &\r\n *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\r\n *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\r\n *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\r\n *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\r\n *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\r\n * )}\r\n */\n\n/**\r\n * @param {string} type\r\n * @param {Props | ChildrenOrValue | null | undefined} [props]\r\n * @param {ChildrenOrValue | null | undefined} [value]\r\n * @returns {Node}\r\n */\nfunction u(type, props, value) {\n  /** @type {Node} */\n  var node = {\n    type: String(type)\n  };\n  if ((value === undefined || value === null) && (typeof props === 'string' || Array.isArray(props))) {\n    value = props;\n  } else {\n    Object.assign(node, props);\n  }\n  if (Array.isArray(value)) {\n    // @ts-expect-error: create a parent.\n    node.children = value;\n  } else if (value !== undefined && value !== null) {\n    // @ts-expect-error: create a literal.\n    node.value = String(value);\n  }\n  return node;\n};","map":{"version":3,"names":["u","type","props","value","node","String","undefined","Array","isArray","Object","assign","children"],"sources":["C:/mayankcse.github.io/node_modules/unist-builder/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('unist').Node} Node\r\n */\r\n\r\n/**\r\n * @typedef {Array<Node> | string} ChildrenOrValue\r\n *   List to use as `children` or value to use as `value`.\r\n *\r\n * @typedef {Record<string, unknown>} Props\r\n *   Other fields to add to the node.\r\n */\r\n\r\n/**\r\n * Build a node.\r\n *\r\n * @param type\r\n *   Node type.\r\n * @param props\r\n *   Fields assigned to node.\r\n * @param value\r\n *   Children of node or value of `node` (cast to string).\r\n * @returns\r\n *   Built node.\r\n */\r\nexport const u =\r\n  /**\r\n   * @type {(\r\n   *   (<T extends string>(type: T) => {type: T}) &\r\n   *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\r\n   *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\r\n   *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\r\n   *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\r\n   *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {string} type\r\n     * @param {Props | ChildrenOrValue | null | undefined} [props]\r\n     * @param {ChildrenOrValue | null | undefined} [value]\r\n     * @returns {Node}\r\n     */\r\n    function (type, props, value) {\r\n      /** @type {Node} */\r\n      const node = {type: String(type)}\r\n\r\n      if (\r\n        (value === undefined || value === null) &&\r\n        (typeof props === 'string' || Array.isArray(props))\r\n      ) {\r\n        value = props\r\n      } else {\r\n        Object.assign(node, props)\r\n      }\r\n\r\n      if (Array.isArray(value)) {\r\n        // @ts-expect-error: create a parent.\r\n        node.children = value\r\n      } else if (value !== undefined && value !== null) {\r\n        // @ts-expect-error: create a literal.\r\n        node.value = String(value)\r\n      }\r\n\r\n      return node\r\n    }\r\n  )\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMA,CAAC;AACZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACI,SAlBSA,CAACA,CAkBAC,IAAI,EAAEC,KAAK,EAAEC,KAAK,EAAE;EAC5B;EACA,IAAMC,IAAI,GAAG;IAACH,IAAI,EAAEI,MAAM,CAACJ,IAAI;EAAC,CAAC;EAEjC,IACE,CAACE,KAAK,KAAKG,SAAS,IAAIH,KAAK,KAAK,IAAI,MACrC,OAAOD,KAAK,KAAK,QAAQ,IAAIK,KAAK,CAACC,OAAO,CAACN,KAAK,CAAC,CAAC,EACnD;IACAC,KAAK,GAAGD,KAAK;EACf,CAAC,MAAM;IACLO,MAAM,CAACC,MAAM,CAACN,IAAI,EAAEF,KAAK,CAAC;EAC5B;EAEA,IAAIK,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,EAAE;IACxB;IACAC,IAAI,CAACO,QAAQ,GAAGR,KAAK;EACvB,CAAC,MAAM,IAAIA,KAAK,KAAKG,SAAS,IAAIH,KAAK,KAAK,IAAI,EAAE;IAChD;IACAC,IAAI,CAACD,KAAK,GAAGE,MAAM,CAACF,KAAK,CAAC;EAC5B;EAEA,OAAOC,IAAI;AACb,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}