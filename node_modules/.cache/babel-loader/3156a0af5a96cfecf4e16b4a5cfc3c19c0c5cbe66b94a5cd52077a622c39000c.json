{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').TokenType} TokenType\r\n */\n\nimport { asciiControl, markdownLineEndingOrSpace, markdownLineEnding } from 'micromark-util-character';\n/**\r\n * Parse destinations.\r\n *\r\n * ###### Examples\r\n *\r\n * ```markdown\r\n * <a>\r\n * <a\\>b>\r\n * <a b>\r\n * <a)>\r\n * a\r\n * a\\)b\r\n * a(b)c\r\n * a(b)\r\n * ```\r\n *\r\n * @param {Effects} effects\r\n *   Context.\r\n * @param {State} ok\r\n *   State switched to when successful.\r\n * @param {State} nok\r\n *   State switched to when unsuccessful.\r\n * @param {TokenType} type\r\n *   Type for whole (`<a>` or `b`).\r\n * @param {TokenType} literalType\r\n *   Type when enclosed (`<a>`).\r\n * @param {TokenType} literalMarkerType\r\n *   Type for enclosing (`<` and `>`).\r\n * @param {TokenType} rawType\r\n *   Type when not enclosed (`b`).\r\n * @param {TokenType} stringType\r\n *   Type for the value (`a` or `b`).\r\n * @param {number | undefined} [max=Infinity]\r\n *   Depth of nested parens (inclusive).\r\n * @returns {State}\r\n *   Start state.\r\n */ // eslint-disable-next-line max-params\nexport function factoryDestination(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {\n  var limit = max || Number.POSITIVE_INFINITY;\n  var balance = 0;\n  return start;\n\n  /**\r\n   * Start of destination.\r\n   *\r\n   * ```markdown\r\n   * > | <aa>\r\n   *     ^\r\n   * > | aa\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type);\n      effects.enter(literalType);\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      return enclosedBefore;\n    }\n\n    // ASCII control, space, closing paren.\n    if (code === null || code === 32 || code === 41 || asciiControl(code)) {\n      return nok(code);\n    }\n    effects.enter(type);\n    effects.enter(rawType);\n    effects.enter(stringType);\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return raw(code);\n  }\n\n  /**\r\n   * After `<`, at an enclosed destination.\r\n   *\r\n   * ```markdown\r\n   * > | <aa>\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function enclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      effects.exit(literalType);\n      effects.exit(type);\n      return ok;\n    }\n    effects.enter(stringType);\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return enclosed(code);\n  }\n\n  /**\r\n   * In enclosed destination.\r\n   *\r\n   * ```markdown\r\n   * > | <aa>\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function enclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString');\n      effects.exit(stringType);\n      return enclosedBefore(code);\n    }\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return code === 92 ? enclosedEscape : enclosed;\n  }\n\n  /**\r\n   * After `\\`, at a special character.\r\n   *\r\n   * ```markdown\r\n   * > | <a\\*a>\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function enclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code);\n      return enclosed;\n    }\n    return enclosed(code);\n  }\n\n  /**\r\n   * In raw destination.\r\n   *\r\n   * ```markdown\r\n   * > | aa\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function raw(code) {\n    if (!balance && (code === null || code === 41 || markdownLineEndingOrSpace(code))) {\n      effects.exit('chunkString');\n      effects.exit(stringType);\n      effects.exit(rawType);\n      effects.exit(type);\n      return ok(code);\n    }\n    if (balance < limit && code === 40) {\n      effects.consume(code);\n      balance++;\n      return raw;\n    }\n    if (code === 41) {\n      effects.consume(code);\n      balance--;\n      return raw;\n    }\n\n    // ASCII control (but *not* `\\0`) and space and `(`.\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\n    // doesnâ€™t.\n    if (code === null || code === 32 || code === 40 || asciiControl(code)) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return code === 92 ? rawEscape : raw;\n  }\n\n  /**\r\n   * After `\\`, at special character.\r\n   *\r\n   * ```markdown\r\n   * > | a\\*a\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function rawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code);\n      return raw;\n    }\n    return raw(code);\n  }\n}","map":{"version":3,"names":["asciiControl","markdownLineEndingOrSpace","markdownLineEnding","factoryDestination","effects","ok","nok","type","literalType","literalMarkerType","rawType","stringType","max","limit","Number","POSITIVE_INFINITY","balance","start","code","enter","consume","exit","enclosedBefore","contentType","raw","enclosed","enclosedEscape","rawEscape"],"sources":["C:/mayankcse.github.io/node_modules/micromark-factory-destination/index.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Effects} Effects\r\n * @typedef {import('micromark-util-types').State} State\r\n * @typedef {import('micromark-util-types').TokenType} TokenType\r\n */\r\n\r\nimport {\r\n  asciiControl,\r\n  markdownLineEndingOrSpace,\r\n  markdownLineEnding\r\n} from 'micromark-util-character'\r\n/**\r\n * Parse destinations.\r\n *\r\n * ###### Examples\r\n *\r\n * ```markdown\r\n * <a>\r\n * <a\\>b>\r\n * <a b>\r\n * <a)>\r\n * a\r\n * a\\)b\r\n * a(b)c\r\n * a(b)\r\n * ```\r\n *\r\n * @param {Effects} effects\r\n *   Context.\r\n * @param {State} ok\r\n *   State switched to when successful.\r\n * @param {State} nok\r\n *   State switched to when unsuccessful.\r\n * @param {TokenType} type\r\n *   Type for whole (`<a>` or `b`).\r\n * @param {TokenType} literalType\r\n *   Type when enclosed (`<a>`).\r\n * @param {TokenType} literalMarkerType\r\n *   Type for enclosing (`<` and `>`).\r\n * @param {TokenType} rawType\r\n *   Type when not enclosed (`b`).\r\n * @param {TokenType} stringType\r\n *   Type for the value (`a` or `b`).\r\n * @param {number | undefined} [max=Infinity]\r\n *   Depth of nested parens (inclusive).\r\n * @returns {State}\r\n *   Start state.\r\n */ // eslint-disable-next-line max-params\r\nexport function factoryDestination(\r\n  effects,\r\n  ok,\r\n  nok,\r\n  type,\r\n  literalType,\r\n  literalMarkerType,\r\n  rawType,\r\n  stringType,\r\n  max\r\n) {\r\n  const limit = max || Number.POSITIVE_INFINITY\r\n  let balance = 0\r\n  return start\r\n\r\n  /**\r\n   * Start of destination.\r\n   *\r\n   * ```markdown\r\n   * > | <aa>\r\n   *     ^\r\n   * > | aa\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    if (code === 60) {\r\n      effects.enter(type)\r\n      effects.enter(literalType)\r\n      effects.enter(literalMarkerType)\r\n      effects.consume(code)\r\n      effects.exit(literalMarkerType)\r\n      return enclosedBefore\r\n    }\r\n\r\n    // ASCII control, space, closing paren.\r\n    if (code === null || code === 32 || code === 41 || asciiControl(code)) {\r\n      return nok(code)\r\n    }\r\n    effects.enter(type)\r\n    effects.enter(rawType)\r\n    effects.enter(stringType)\r\n    effects.enter('chunkString', {\r\n      contentType: 'string'\r\n    })\r\n    return raw(code)\r\n  }\r\n\r\n  /**\r\n   * After `<`, at an enclosed destination.\r\n   *\r\n   * ```markdown\r\n   * > | <aa>\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function enclosedBefore(code) {\r\n    if (code === 62) {\r\n      effects.enter(literalMarkerType)\r\n      effects.consume(code)\r\n      effects.exit(literalMarkerType)\r\n      effects.exit(literalType)\r\n      effects.exit(type)\r\n      return ok\r\n    }\r\n    effects.enter(stringType)\r\n    effects.enter('chunkString', {\r\n      contentType: 'string'\r\n    })\r\n    return enclosed(code)\r\n  }\r\n\r\n  /**\r\n   * In enclosed destination.\r\n   *\r\n   * ```markdown\r\n   * > | <aa>\r\n   *      ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function enclosed(code) {\r\n    if (code === 62) {\r\n      effects.exit('chunkString')\r\n      effects.exit(stringType)\r\n      return enclosedBefore(code)\r\n    }\r\n    if (code === null || code === 60 || markdownLineEnding(code)) {\r\n      return nok(code)\r\n    }\r\n    effects.consume(code)\r\n    return code === 92 ? enclosedEscape : enclosed\r\n  }\r\n\r\n  /**\r\n   * After `\\`, at a special character.\r\n   *\r\n   * ```markdown\r\n   * > | <a\\*a>\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function enclosedEscape(code) {\r\n    if (code === 60 || code === 62 || code === 92) {\r\n      effects.consume(code)\r\n      return enclosed\r\n    }\r\n    return enclosed(code)\r\n  }\r\n\r\n  /**\r\n   * In raw destination.\r\n   *\r\n   * ```markdown\r\n   * > | aa\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function raw(code) {\r\n    if (\r\n      !balance &&\r\n      (code === null || code === 41 || markdownLineEndingOrSpace(code))\r\n    ) {\r\n      effects.exit('chunkString')\r\n      effects.exit(stringType)\r\n      effects.exit(rawType)\r\n      effects.exit(type)\r\n      return ok(code)\r\n    }\r\n    if (balance < limit && code === 40) {\r\n      effects.consume(code)\r\n      balance++\r\n      return raw\r\n    }\r\n    if (code === 41) {\r\n      effects.consume(code)\r\n      balance--\r\n      return raw\r\n    }\r\n\r\n    // ASCII control (but *not* `\\0`) and space and `(`.\r\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\r\n    // doesnâ€™t.\r\n    if (code === null || code === 32 || code === 40 || asciiControl(code)) {\r\n      return nok(code)\r\n    }\r\n    effects.consume(code)\r\n    return code === 92 ? rawEscape : raw\r\n  }\r\n\r\n  /**\r\n   * After `\\`, at special character.\r\n   *\r\n   * ```markdown\r\n   * > | a\\*a\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function rawEscape(code) {\r\n    if (code === 40 || code === 41 || code === 92) {\r\n      effects.consume(code)\r\n      return raw\r\n    }\r\n    return raw(code)\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}