{"ast":null,"code":"/**\r\n * @typedef {import('mdast').LinkReference} LinkReference\r\n * @typedef {import('mdast').ImageReference} ImageReference\r\n * @typedef {import('./index.js').Handler} Handler\r\n * @typedef {import('./index.js').Content} Content\r\n */\n\nimport { u } from 'unist-builder';\nimport { all } from './traverse.js';\n\n/**\r\n * Return the content of a reference without definition as plain text.\r\n *\r\n * @type {Handler}\r\n * @param {ImageReference|LinkReference} node\r\n * @returns {Content|Array.<Content>}\r\n */\nexport function revert(h, node) {\n  var subtype = node.referenceType;\n  var suffix = ']';\n  if (subtype === 'collapsed') {\n    suffix += '[]';\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']';\n  }\n  if (node.type === 'imageReference') {\n    return u('text', '![' + node.alt + suffix);\n  }\n  var contents = all(h, node);\n  var head = contents[0];\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value;\n  } else {\n    contents.unshift(u('text', '['));\n  }\n  var tail = contents[contents.length - 1];\n  if (tail && tail.type === 'text') {\n    tail.value += suffix;\n  } else {\n    contents.push(u('text', suffix));\n  }\n  return contents;\n}","map":{"version":3,"names":["u","all","revert","h","node","subtype","referenceType","suffix","label","identifier","type","alt","contents","head","value","unshift","tail","length","push"],"sources":["C:/Users/mayan/source/repos/mayankcse.github.io/node_modules/mdast-util-to-hast/lib/revert.js"],"sourcesContent":["/**\r\n * @typedef {import('mdast').LinkReference} LinkReference\r\n * @typedef {import('mdast').ImageReference} ImageReference\r\n * @typedef {import('./index.js').Handler} Handler\r\n * @typedef {import('./index.js').Content} Content\r\n */\r\n\r\nimport {u} from 'unist-builder'\r\nimport {all} from './traverse.js'\r\n\r\n/**\r\n * Return the content of a reference without definition as plain text.\r\n *\r\n * @type {Handler}\r\n * @param {ImageReference|LinkReference} node\r\n * @returns {Content|Array.<Content>}\r\n */\r\nexport function revert(h, node) {\r\n  const subtype = node.referenceType\r\n  let suffix = ']'\r\n\r\n  if (subtype === 'collapsed') {\r\n    suffix += '[]'\r\n  } else if (subtype === 'full') {\r\n    suffix += '[' + (node.label || node.identifier) + ']'\r\n  }\r\n\r\n  if (node.type === 'imageReference') {\r\n    return u('text', '![' + node.alt + suffix)\r\n  }\r\n\r\n  const contents = all(h, node)\r\n  const head = contents[0]\r\n\r\n  if (head && head.type === 'text') {\r\n    head.value = '[' + head.value\r\n  } else {\r\n    contents.unshift(u('text', '['))\r\n  }\r\n\r\n  const tail = contents[contents.length - 1]\r\n\r\n  if (tail && tail.type === 'text') {\r\n    tail.value += suffix\r\n  } else {\r\n    contents.push(u('text', suffix))\r\n  }\r\n\r\n  return contents\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,CAAC,QAAO,eAAe;AAC/B,SAAQC,GAAG,QAAO,eAAe;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACC,CAAC,EAAEC,IAAI,EAAE;EAC9B,IAAMC,OAAO,GAAGD,IAAI,CAACE,aAAa;EAClC,IAAIC,MAAM,GAAG,GAAG;EAEhB,IAAIF,OAAO,KAAK,WAAW,EAAE;IAC3BE,MAAM,IAAI,IAAI;EAChB,CAAC,MAAM,IAAIF,OAAO,KAAK,MAAM,EAAE;IAC7BE,MAAM,IAAI,GAAG,IAAIH,IAAI,CAACI,KAAK,IAAIJ,IAAI,CAACK,UAAU,CAAC,GAAG,GAAG;EACvD;EAEA,IAAIL,IAAI,CAACM,IAAI,KAAK,gBAAgB,EAAE;IAClC,OAAOV,CAAC,CAAC,MAAM,EAAE,IAAI,GAAGI,IAAI,CAACO,GAAG,GAAGJ,MAAM,CAAC;EAC5C;EAEA,IAAMK,QAAQ,GAAGX,GAAG,CAACE,CAAC,EAAEC,IAAI,CAAC;EAC7B,IAAMS,IAAI,GAAGD,QAAQ,CAAC,CAAC,CAAC;EAExB,IAAIC,IAAI,IAAIA,IAAI,CAACH,IAAI,KAAK,MAAM,EAAE;IAChCG,IAAI,CAACC,KAAK,GAAG,GAAG,GAAGD,IAAI,CAACC,KAAK;EAC/B,CAAC,MAAM;IACLF,QAAQ,CAACG,OAAO,CAACf,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;EAClC;EAEA,IAAMgB,IAAI,GAAGJ,QAAQ,CAACA,QAAQ,CAACK,MAAM,GAAG,CAAC,CAAC;EAE1C,IAAID,IAAI,IAAIA,IAAI,CAACN,IAAI,KAAK,MAAM,EAAE;IAChCM,IAAI,CAACF,KAAK,IAAIP,MAAM;EACtB,CAAC,MAAM;IACLK,QAAQ,CAACM,IAAI,CAAClB,CAAC,CAAC,MAAM,EAAEO,MAAM,CAAC,CAAC;EAClC;EAEA,OAAOK,QAAQ;AACjB"},"metadata":{},"sourceType":"module","externalDependencies":[]}